//
//  Day17VC.swift
//  AdventOfCode2019
//
//  Created by Geir-Kåre S. Wærp on 17/12/2019.
//  Copyright © 2019 GK. All rights reserved.
//

import UIKit

class Day17VC: AoCVC, AdventDay {
    
    let machine = IntMachine()
    func loadInput() {
        let line = FileLoader.loadText(fileName: "Day17Input").first!.components(separatedBy: ",")
        let program = line.map({Int($0)!})
        self.machine.loadNewProgram(memory: program)
    }
    
    func asciiToText(_ raw: Int) -> String {
        let asciiValue = UnicodeScalar(raw)!
        return "\(Character(asciiValue))"
    }
    
    func solveFirst() {
        var outputString = ""
        self.machine.run { (outputValue) in
            outputString.append(self.asciiToText(outputValue))
        }
        print(outputString)
        
        self.cameraMap = self.cameraMapFromString(outputString)
        let intersections = self.findIntersections(in: self.cameraMap)
        let result = intersections.map { (intersectionPoint) -> Int in
            intersectionPoint.x * intersectionPoint.y
        }.reduce(0, +)
        
        self.setSolution1("\(result)")
    }
    
    enum MapTileType {
        case empty
        case scaffold
        case robot
        
        static func from(string: String) -> (mapTile: MapTileType, robotDirection: Direction?) {
            switch string {
            case ".": return (.empty, nil)
            case "#": return (.scaffold, nil)
            case "^": return (.robot, .north)
            case "v": return (.robot, .south)
            case "<": return (.robot, .west)
            case ">": return (.robot, .east)
            default: fatalError()
            }
        }
    }
    
    struct Robot {
        var position: IntPoint!
        var direction: Direction!
    }
    
    var cameraMap = [IntPoint: MapTileType]()
    var robot = Robot()
    
    func cameraMapFromString(_ string: String) -> [IntPoint: MapTileType] {
        var parsedMap = [IntPoint: MapTileType]()
        let lines = string.components(separatedBy: "\n")
        var y = 0
        for line in lines {
            var x = 0
            for char in line {
                let position = IntPoint(x: x, y: y)
                let mapTileInfo = MapTileType.from(string: "\(char)")
                if mapTileInfo.mapTile != .robot {
                    parsedMap[position] = mapTileInfo.mapTile
                } else {
                    parsedMap[position] = .scaffold
                    self.robot.position = position
                    self.robot.direction = mapTileInfo.robotDirection!
                }
                x += 1
            }
            y += 1
        }
        return parsedMap
    }
    
    func findIntersections(in map: [IntPoint: MapTileType]) -> [IntPoint] {
        var intersections = [IntPoint]()
        let gridInfo = IntPoint.gridInfo(from: map.keys)
        let gridPoints = IntPoint.gridPoints(x: gridInfo.width, y: gridInfo.height)
        for rawPoint in gridPoints {
            let actualPoint = rawPoint + gridInfo.minExtents
            guard map[actualPoint] == .scaffold else { continue }
            
            var numClose = 0
            for direction in Direction.allCases {
                let checkedPos = actualPoint + direction.movementVector
                if map[checkedPos] == .scaffold {
                    numClose += 1
                }
            }
            if numClose >= 3 {
                intersections.append(actualPoint)
            }
        }
        
        return intersections
    }
    
    func solveSecond() {
        self.machine.reset()
        self.machine.setMemoryDirect(memoryAddress: 0, value: 2)
        
        // Manually generated by looking at map
        // let fullPath = "L,6,R,12,R,8,R,8,R,12,L,12,R,8,R,12,L,12,L,6,R,12,R,8,R,12,L,12,L,4,L,4,L,6,R,12,R,8,R,12,L,12,L,4,L,4,L,6,R,12,R,8,R,12,L,12,L,4,L,4,R,8,R,12,L,12"
        let mainMovement = "A,B,B,A,C,A,C,A,C,B\n".map({Int($0.asciiValue!)})
        let movementA = "L,6,R,12,R,8\n".map({Int($0.asciiValue!)})
        let movementB = "R,8,R,12,L,12\n".map({Int($0.asciiValue!)})
        let movementC = "R,12,L,12,L,4,L,4\n".map({Int($0.asciiValue!)})
        let liveFeed = "n\n".map({Int($0.asciiValue!)})
        
        self.machine.inputs.append(contentsOf: mainMovement)
        self.machine.inputs.append(contentsOf: movementA)
        self.machine.inputs.append(contentsOf: movementB)
        self.machine.inputs.append(contentsOf: movementC)
        self.machine.inputs.append(contentsOf: liveFeed)
        
        var lastOutput = 0
        self.machine.run { (outputValue) in
            lastOutput = outputValue
        }
        self.setSolution2("\(lastOutput)")
    }
}
